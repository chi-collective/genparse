"""
Fast computation of the posterior distrubtion over the next word in a WCFG language model.
"""

import numpy as np
from functools import lru_cache
from collections import Counter
from arsenal.maths import sample_dict

from .cfg import CFG, _gen_nt
from . import Chart
from .semiring import Float


def locally_normalize(self, **kwargs):
    """
    Locally normalizes the grammar: return a transformed grammar such that

    (1) the total weight of each block of rules with a common head sum to one;

    (2) each derivation in the transformed grammar is proportional to the original grammar
        (i.e., it is has the same score modulo a multiplicative normalization constant)

    """
    new = self.spawn()
    Z = self.agenda(**kwargs)
    for r in self:
        if Z[r.head] == 0: continue
        new.add(r.w * Z.product(r.body) / Z[r.head], r.head, *r.body)
    return new


class CFGLM:

    def __init__(self, cfg):
        self.cfg = cfg
        self.pfg = cfg.cnf.prefix_grammar.cnf

    @lru_cache(None)
    def chart(self, prefix):
        if len(prefix) == 0:
            return self.pfg._parse_chart([])
        else:
            chart = self.chart(prefix[:-1])
            return extend_chart(self.pfg, chart, prefix)

    @lru_cache(None)
    def p_next(self, prefix):
        chart = self.chart(prefix)
        return next_token_weights(self.pfg, chart, prefix)

    def sample(self, draw=sample_dict, verbose=False):
        ys = []
        while True:
            p = self.p_next(tuple(ys))
            if verbose: print(ys)
            y = draw(p)
            if y == EOS: return ys
            ys.append(y)


def next_token_weights(cfg, chart, prefix):
    """
    An O(NÂ²) time algorithm to extend to the `chart` with the last token
    appearing at the end of `s`; returns a new chart.
    """
    k = len(prefix) + 1

    (nullary, terminal, binary) = cfg._cnf

    # the code below is just backprop / outside algorithm
    Î± = cfg.R.chart()
    Î±[0, cfg.S] += cfg.R.one

    # Binary rules
    for span in reversed(range(1, k + 1)):
        i = k - span
        for j in range(i + 1, k):
            for r in binary:
                X, [Y, Z] = r.head, r.body
                Î±[j, Z] += r.w * chart[i, Y, j] * Î±[i, X]

    # Preterminal
    q = cfg.R.chart()
    for w in cfg.V:
        for r in terminal[w]:
            q[w] += r.w * Î±[k-1, r.head]

    return Chart(cfg.R, q)


def extend_chart(cfg, chart, s):
    """
    An O(NÂ²) time algorithm to extend to the `chart` with the last token
    appearing at the end of `s`; returns a new chart.
    """
    k = len(s)

    (nullary, terminal, binary) = cfg._cnf

    # TODO: This is an unnecessarily expensive O(N^2) copy operation. We can
    # speed it up by representing the chart as an end-position-indexed
    # collection of sub-charts.
    c = chart.copy()

    # Nullary
    c[k, cfg.S, k] += nullary

    # Preterminal
    for r in terminal[s[k-1]]:
        c[k-1, r.head, k] += r.w

    # Binary rules
    for span in range(1, k+1):
        i = k - span
        for j in range(i + 1, k):
            for r in binary:
                X, [Y, Z] = r.head, r.body
                c[i, X, k] += r.w * c[i, Y, j] * c[j, Z, k]
    return c


#EOS = '$EOS'
#EOS = 'ðŸ›‘'
EOS = 'â–ª'


# spacer is a kind of end-of-token marker
#SPACER = '$SPACER'
SPACER = '#'
#EOT = '#'


# TODO: better to use concatenation of grammars!
def add_EOS(cfg, EOS=EOS):
    "Append the EOS symbol to the language generated by `cfg`."
    S = _gen_nt('<START>')
    new = cfg.spawn(S=S)
    assert EOS not in cfg.V
    new.V.add(EOS)
    new.add(cfg.R.one, S, cfg.S, EOS)
    for r in cfg:
        new.add(r.w, r.head, *r.body)
    return new


def explode_terminal(y):
    assert y != SPACER
    if y == EOS:      # don't explode EOS!
        return [y]
    else:
        return list(y + SPACER)


def explode(cfg):
    """
    Explode the terminals into characters - this is a special case of composition
    with a transducer.
    """
    new = cfg.spawn(V = set())
    for r in cfg:
        ys = []
        for y in r.body:
            if cfg.is_terminal(y):
                yy = explode_terminal(y)
                ys.extend(yy)
                new.V |= set(yy)
            else:
                ys.append(y)
        new.add(r.w, r.head, *ys)
    return new
