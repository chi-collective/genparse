"""
Fast computation of the posterior distrubtion over the next word in a WCFG language model.
"""

from arsenal import colors
from arsenal.maths import sample_dict
from collections import defaultdict

from genparse.cfg import _gen_nt, CFG
from genparse.lm import LM
from genparse.semiring import Float


#EOS = '$EOS'
#EOS = 'ðŸ›‘'
EOS = 'â–ª'

# spacer is a kind of end-of-token marker
#SPACER = '$SPACER'
SPACER = '#'
#EOT = '#'

ERROR = 'ðŸ’¥'


def locally_normalize(self, **kwargs):
    """
    Locally normalizes the grammar: return a transformed grammar such that

    (1) the total weight of each block of rules with a common head sum to one;

    (2) each derivation in the transformed grammar is proportional to the original grammar
        (i.e., it is has the same score modulo a multiplicative normalization constant)

    """
    new = self.spawn()
    Z = self.agenda(**kwargs)
    for r in self:
        if Z[r.head] == 0: continue
        new.add(r.w * Z.product(r.body) / Z[r.head], r.head, *r.body)
    return new


class CFGLM(LM):

    def __init__(self, cfg, renumber=True):
        if EOS not in cfg.V: cfg = add_EOS(cfg)

        # cache columns of the chart indexed by prefix
        self._chart = {}

        if renumber:
            self.cfg = cfg.renumber()
            self.pfg = cfg.cnf.prefix_grammar.cnf.renumber().cnf
        else:
            self.cfg = cfg
            self.pfg = cfg.cnf.prefix_grammar.cnf

        # TODO: this is is a quick hack; clean this up.
        self.pfg.r_y_xz = r_y_xz = defaultdict(list)
        for r in self.pfg._cnf[2]:  # binary rules
            r_y_xz[r.body[0]].append(r)

        super().__init__(V = cfg.V, eos = EOS)

    def __call__(self, x):
        assert x[-1] == EOS
        # the quantity below is equivalent to `self.cfg(x)`
        return self.chart(x)[len(x)][0][self.pfg.S]

    def p_next(self, prefix):
        chart = self.chart(prefix)
        return next_token_weights(self.pfg, chart, prefix)

    # TODO: should probably be PCFGLM class, which is tied to semifields, rather
    # than CFGLM, which is meant to semiring-friendly.
    @classmethod
    def from_string(cls, x, semiring=Float, **kwargs):
        return cls(locally_normalize(CFG.from_string(x, semiring), **kwargs))

    def chart(self, prefix):
        c = self._chart.get(prefix)
        if c is None:
            c = self._compute_chart(prefix)
            self._chart[prefix] = c
        return c

    def _compute_chart(self, prefix):
        if len(prefix) == 0:
            tmp = [defaultdict(self.pfg.R.chart)]
            tmp[0][0][self.pfg.S] = self.pfg('')
            return tmp
        else:
            chart = self.chart(prefix[:-1])
            last_chart = extend_chart(self.pfg, chart, prefix)
            return chart + [last_chart]    # TODO: avoid list addition here as it is not constant time!


def next_token_weights(cfg, chart, prefix, alpha=False):
    """
    An O(NÂ²) time algorithm to the total weight of a each next-token
    extension of `prefix`.
    """
    k = len(prefix) + 1

    (_, terminal, _) = cfg._cnf
    r_y_xz = cfg.r_y_xz

    # the code below is just backprop / outside algorithm
    Î± = defaultdict(cfg.R.chart)
    Î±[0][cfg.S] += cfg.R.one

    # Binary rules
    for span in reversed(range(2, k + 1)):
        i = k - span
        Î±_i = Î±[i]
        for j in range(i + 1, k):
            chart_ij = chart[j][i]

            Î±_j = Î±[j]
            for Y, y in chart_ij.items():
                for r in r_y_xz[Y]:
                    X = r.head
                    Z = r.body[1]
                    Î±_j[Z] += r.w * y * Î±_i[X]

    # Preterminal
    q = cfg.R.chart()
    tmp = Î±[k-1]
    for w in cfg.V:
        for r in terminal[w]:
            q[w] += r.w * tmp[r.head]

    if alpha:
        return q, Î±
    else:
        return q


def extend_chart(cfg, chart, prefix):
    """
    An O(NÂ²) time algorithm to extend to the `chart` with the last token
    appearing at the end of `prefix`; returns a new chart column.
    """
    k = len(prefix)

    (nullary, terminal, _) = cfg._cnf
    r_y_xz = cfg.r_y_xz

    new = defaultdict(cfg.R.chart)

    # Nullary
    new[k][cfg.S] += nullary

    # Preterminal
    tmp = new[k-1]
    for r in terminal[prefix[k-1]]:
        tmp[r.head] += r.w

    # Binary rules
    for span in range(2, k+1):
        i = k - span
        new_i = new[i]
        for j in range(i + 1, k):
            chart_ij = chart[j][i]
            new_j = new[j]
            for Y, y in chart_ij.items():
                for r in r_y_xz[Y]:
                    X = r.head
                    Z = r.body[1]
                    z = new_j[Z]
                    x = r.w * y * z
                    new_i[X] += x

    return new


def add_EOS(cfg):
    "Append the EOS symbol to the language generated by `cfg`."
    S = _gen_nt('<START>')
    new = cfg.spawn(S=S)
    assert EOS not in cfg.V
    new.V.add(EOS)
    new.add(cfg.R.one, S, cfg.S, EOS)
    for r in cfg:
        new.add(r.w, r.head, *r.body)
    return new


def explode_terminal(y):
    assert y != SPACER
    if y == EOS:      # don't explode EOS!
        return [y]
    else:
        return list(y + SPACER)


def explode(cfg):
    """
    Explode the terminals into characters - this is a special case of composition
    with a transducer.
    """
    new = cfg.spawn(V = set())
    for r in cfg:
        ys = []
        for y in r.body:
            if cfg.is_terminal(y):
                yy = explode_terminal(y)
                ys.extend(yy)
                new.V |= set(yy)
            else:
                ys.append(y)
        new.add(r.w, r.head, *ys)
    return new


def pcfg_check(cfg):
    chart = cfg.agenda()
    if all((0 <= v <= 1.000001) for v in chart.values()):
        print(colors.mark(True), 'PCFG')
    else:
        print(colors.mark(False), 'PCFG', chart.__str__(style_value=lambda k, v: v if abs(1 - v) <= 1e-5 else (colors.light.red % v)))


def cfg_check_bounded(cfg, ub=1.000001, lb=0):
    chart = cfg.agenda()
    if all((lb <= v <= ub) for v in chart.values()):
        print(colors.mark(True), 'PCFG')
    else:
        print(colors.mark(False), 'PCFG', chart.__str__(style_value=lambda k, v: v if lb <= v <= ub else (colors.light.red % v)))
