"""
Fast computation of the posterior distrubtion over the next word in a WCFG language model.
"""

from arsenal import colors

from genparse.cfg import CFG, _gen_nt
from genparse.lm import LM
from genparse.semiring import Boolean, Float


# EOS = '$EOS'
# EOS = 'ðŸ›‘'
EOS = 'â–ª'


def locally_normalize(self, **kwargs):
    """
    Locally normalizes the grammar: return a transformed grammar such that

    (1) the total weight of each block of rules with a common head sum to one;

    (2) each derivation in the transformed grammar is proportional to the original grammar
        (i.e., it is has the same score modulo a multiplicative normalization constant)

    """
    new = self.spawn()
    Z = self.agenda(**kwargs)
    for r in self:
        if Z[r.head] == 0:
            continue
        new.add(r.w * Z.product(r.body) / Z[r.head], r.head, *r.body)
    return new


class BoolCFGLM(LM):
    "LM-like interface for Boolean-masking CFG models; uses Earley's algorithm for inference."

    def __init__(self, cfg, alg='earley'):
        if EOS not in cfg.V:
            cfg = add_EOS(cfg)
        if cfg.R != Boolean:
            cfg = cfg.map_values(lambda x: Boolean(x > 0), Boolean)
        if alg == 'earley':
            from genparse.parse.earley import Earley

            self.model = Earley(cfg.prefix_grammar)
        elif alg == 'cky':
            from genparse.parse.cky import CKYLM

            self.model = CKYLM(cfg)
        else:
            raise ValueError(f'unrecognized option {alg}')
        super().__init__(eos=EOS, V=cfg.V)

    def p_next(self, context):
        p = self.model.p_next(context).trim()
        return Float.chart({w: 1 for w in p})

    def __call__(self, context):
        return float(super().__call__(context) > 0)

    def clear_cache(self):
        self.model.clear_cache()

    @classmethod
    def from_string(cls, x, semiring=Boolean, **kwargs):
        return cls(CFG.from_string(x, semiring), **kwargs)


def add_EOS(cfg):
    "Append the EOS symbol to the language generated by `cfg`."
    S = _gen_nt('<START>')
    new = cfg.spawn(S=S)
    assert EOS not in cfg.V
    new.V.add(EOS)
    new.add(cfg.R.one, S, cfg.S, EOS)
    for r in cfg:
        new.add(r.w, r.head, *r.body)
    return new


def pcfg_check(cfg, verbose=True):
    chart = cfg.agenda()
    if all((0 <= v <= 1.000001) for v in chart.values()):
        if verbose:
            print(colors.mark(True), 'PCFG')
        return True
    else:
        if verbose:
            print(
                colors.mark(False),
                'PCFG',
                chart.__str__(
                    style_value=lambda k, v: (
                        v if abs(1 - v) <= 1e-5 else (colors.light.red % v)
                    )
                ),
            )
        return False


# def cfg_check_bounded(cfg, ub=1.000001, lb=0):
#    chart = cfg.agenda()
#    if all((lb <= v <= ub) for v in chart.values()):
#        print(colors.mark(True), 'PCFG')
#    else:
#        print(
#            colors.mark(False),
#            'PCFG',
#            chart.__str__(
#                style_value=lambda k, v: v if lb <= v <= ub else (colors.light.red % v)
#            ),
#        )
