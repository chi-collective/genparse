"""
Fast computation of the posterior distrubtion over the next word in a WCFG language model.
"""

from arsenal import colors

from genparse.cfg import CFG, _gen_nt
from genparse.lm import LM
from genparse.semiring import Boolean, Float
from genparse.parse.cky import IncrementalCKY

# EOS = '$EOS'
# EOS = 'ðŸ›‘'
EOS = 'â–ª'

# EOT = '#'

ERROR = 'ðŸ’¥'


def locally_normalize(self, **kwargs):
    """
    Locally normalizes the grammar: return a transformed grammar such that

    (1) the total weight of each block of rules with a common head sum to one;

    (2) each derivation in the transformed grammar is proportional to the original grammar
        (i.e., it is has the same score modulo a multiplicative normalization constant)

    """
    new = self.spawn()
    Z = self.agenda(**kwargs)
    for r in self:
        if Z[r.head] == 0:
            continue
        new.add(r.w * Z.product(r.body) / Z[r.head], r.head, *r.body)
    return new


# class BoolMaskCFGLM(LM):
#    "LM-like interface for Boolean-masking CFG models; uses CKY for inference."
#
#    def __init__(self, cfg):
#        if EOS not in cfg.V:
#            cfg = add_EOS(cfg)
#        if cfg.R != Boolean:
#            cfg = cfg.map_values(lambda x: Boolean(x > 0), Boolean)
#        self.model = CFGLM(cfg)
#        super().__init__(eos=self.model.eos, V=self.model.V)
#
#    def p_next(self, context):
#        p = self.model.p_next(context).trim()
#        return Float.chart({w: 1 for w in p})
#
#    def __call__(self, context):
#        assert context[-1] == EOS
#        return float(self.model(context) != Boolean.zero)
#
#    def clear_cache(self):
#        self.model.clear_cache()


class BoolMaskCFGLM(LM):
    "LM-like interface for Boolean-masking CFG models; uses Earley's algorithm for inference."

    def __init__(self, cfg, alg='earley'):
        if EOS not in cfg.V:
            cfg = add_EOS(cfg)
        if cfg.R != Boolean:
            cfg = cfg.map_values(lambda x: Boolean(x > 0), Boolean)
        if alg == 'earley':
            from genparse.parse.earley import Earley

            self.model = Earley(cfg.prefix_grammar)
        elif alg == 'cky':
            self.model = CFGLM(cfg)
        else:
            raise ValueError(f'unrecognized option {alg}')
        super().__init__(eos=EOS, V=cfg.V)

    def p_next(self, context):
        p = self.model.p_next(context).trim()
        return Float.chart({w: 1 for w in p})

    def __call__(self, context):
        assert context[-1] == EOS
        return float(self.model(context) != Boolean.zero)

    def clear_cache(self):
        self.model.clear_cache()

    @classmethod
    def from_string(cls, x, semiring=Boolean, **kwargs):
        return cls(CFG.from_string(x, semiring), **kwargs)


EarleyBoolMaskCFGLM = BoolMaskCFGLM


class CFGLM(LM):
    """
    Probabilistic Context-Free Grammar Language Model.

    Uses CKY and the prefix grammar transformation for efficient inference.
    """

    def __init__(self, cfg, **kwargs):
        if EOS not in cfg.V:
            cfg = add_EOS(cfg)

        self.cfg = cfg
        self.pfg = self.cfg.cnf.prefix_grammar.cnf
        self.model = IncrementalCKY(self.pfg, **kwargs)

        super().__init__(V=cfg.V, eos=EOS)

    def __call__(self, x):
        assert x[-1] == EOS
        return self.model(x)

    def p_next(self, prefix):
        return self.model.p_next(prefix)

    @classmethod
    def from_string(cls, x, semiring=Float, **kwargs):
        return cls(locally_normalize(CFG.from_string(x, semiring), **kwargs))

    def assert_pcfg(self, verbose=False):
        assert pcfg_check(self.cfg, verbose=verbose)

    def clear_cache(self):
        self.model.clear_cache()


def add_EOS(cfg):
    "Append the EOS symbol to the language generated by `cfg`."
    S = _gen_nt('<START>')
    new = cfg.spawn(S=S)
    assert EOS not in cfg.V
    new.V.add(EOS)
    new.add(cfg.R.one, S, cfg.S, EOS)
    for r in cfg:
        new.add(r.w, r.head, *r.body)
    return new


def pcfg_check(cfg, verbose=True):
    chart = cfg.agenda()
    if all((0 <= v <= 1.000001) for v in chart.values()):
        if verbose:
            print(colors.mark(True), 'PCFG')
        return True
    else:
        if verbose:
            print(
                colors.mark(False),
                'PCFG',
                chart.__str__(
                    style_value=lambda k, v: (
                        v if abs(1 - v) <= 1e-5 else (colors.light.red % v)
                    )
                ),
            )
        return False


def cfg_check_bounded(cfg, ub=1.000001, lb=0):
    chart = cfg.agenda()
    if all((lb <= v <= ub) for v in chart.values()):
        print(colors.mark(True), 'PCFG')
    else:
        print(
            colors.mark(False),
            'PCFG',
            chart.__str__(
                style_value=lambda k, v: v if lb <= v <= ub else (colors.light.red % v)
            ),
        )
